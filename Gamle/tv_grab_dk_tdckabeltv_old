#!/usr/bin/perl -w
use strict;

# If you enable this, remember to delete the /tmp files sometimes. The
# GET result contains a jsessionid that times out on the tdckabeltv.dk
# site after "a while" :-D
my $debug;
# $debug = "parse";
# $debug = "sequence";
my $debugGetContentsFile = "/tmp/getcontent.html";
my $debugPostContentsFile = "/tmp/postcontent.html";

# default language
my $LANG = 'da';

=pod

=head1 NAME

tv_grab_dk_tdckabeltv - Grab TV listings for Denmark.

=head1 SYNOPSIS

tv_grab_dk_tdckabeltv --help

tv_grab_dk_tdckabeltv [--config-file FILE] --configure

tv_grab_dk_tdckabeltv [--config-file FILE] --check-channels

tv_grab_dk_tdckabeltv [--config-file FILE] [--output FILE]

=head1 DESCRIPTION

Output TV listings for several channels available in Denmark.  The
data comes from http://tdckabeltv.dk/?UniversID=3 (TDC). The grabber
relies on parsing HTML so it might stop working at any time.

First run B<tv_grab_dk_tdckabeltv --configure> to choose, which
channels you want to download. Then running B<tv_grab_dk_tdckabeltv>
with no arguments will output listings in XML format to standard
output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_dk_tdckabeltv.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--check-channels> Check to see if there are any new/removed/renamed channels

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is one week.

B<--offset N> start N days in the future.  The default is to start
from today.

B<--quiet> suppress the progress messages normally written to standard
error.

=head2 XMLTV IDs

The channels have names, such as "DR 1". Channel names match:

 m|[a-zA-Z /\.]|

To convert a channel name to a xmltvid we replace ' ' with '_', '/"
with '%" and '.' with '-', and append ".tdckabeltv.dk". This translation
is reversible, because the target characters aren't present in any
channel names (aren't we lucky! :-D)

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

* Johnathan Motzfeld (jmotzfeld@hotpop.com) 
* modified Peter Mørch's (peter@remove_underscores_m_o_r_c_h.com) 
  tv_grab_dk_alt 
* who had modified Jesper Skov (jskov@zoftcorp.dk)'s tv_grab_dk
* which was based on tv_grab_nl by Guido Diepen 
* and Ed Avis (ed@membled.com) and
* tv_grab_fi by Matti Airas.

=head1 BUGS

Probably several. None known at this time. Works for me! :-D

=cut

use XMLTV::Version '0.1 Subversion revision nr: $Id:$';
use Getopt::Long;
use LWP::Simple ();
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;
use URI;

use Date::Manip;
# Beware - I've seen dates like:
# Fredag d. 01 october 2004
# - A mix of languages!!
# Date_Init("Language=Danish","DateFormat=non-US");
Date_Init("DateFormat=non-US");

use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Mode;
use XMLTV::Config_file;
# use XMLTV::TZ;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
tv_grab_dk_tdckabeltv: get Danish television listings in XMLTV format
To configure    : tv_grab_dk_tdckabeltv --configure [--config-file FILE]
To grab listings: tv_grab_dk_tdckabeltv [--config-file FILE] [--output FILE]
To check chans  : tv_grab_dk_tdckabeltv --check-channels [--config-file FILE] 
END
  ;

# Use Term::ProgressBar if installed.
use constant Have_bar => eval { require Term::ProgressBar; 1 };

my $TDCgetURL = 'http://tdckabeltv.dk/appmanager/ktv/privat?_nfpb=true&_pageLabel=tvguide&_nfls=false';
my $xmltvidSuffix = '.tdckabeltv.dk';

use LWP::UserAgent;
my $ua = LWP::UserAgent->new(keep_alive => 1,
			     timeout => 120,
			    );

my ($opt_days, $opt_offset, $opt_help, $opt_output,
    $opt_configure, , $opt_check_channels,
    $opt_config_file, $opt_quiet);
$opt_days   = 7; # default
$opt_offset = 0; # default
GetOptions('days=i'         => \$opt_days,
	   'offset=i'       => \$opt_offset,
	   'help'           => \$opt_help,
	   'configure'      => \$opt_configure,
	   'check-channels' => \$opt_check_channels,
	   'config-file=s'  => \$opt_config_file,
	   'output=s'       => \$opt_output,
	   'quiet'          => \$opt_quiet,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

my $mode = XMLTV::Mode::mode('grab', # default
			     $opt_configure => 'configure',
			     $opt_check_channels => 'check-channels',
			    );
# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 
				 'tv_grab_dk_tdckabeltv', 
				 $opt_quiet);

################################################################################
# Convert channel name to xmltvid and vice-versa
################################################################################
sub getXmltvid {
  my ($channelName) = @_;
  my $xmltvid = $channelName;
  $xmltvid =~ tr| ./|_\-%|;
  return $xmltvid . $xmltvidSuffix;
}

sub getChannelName {
  my ($xmltvid) = @_;
  my $channelName = $xmltvid;
  $channelName =~ s/$xmltvidSuffix$//;
  $channelName =~ tr|_\-%| ./|;
  return $channelName;
}

################################################################################
# If needed, get the main page to get a list of categories ("emner"),
# that we must select (we'll just select them all).
################################################################################
my $_initialGetTree;
sub getInitialGetTree {
  if (! defined $_initialGetTree) {
    print STDERR "Fetching initial info from TDC... Please wait...\n";
    my $getContent;
    if (!$debug || ! -r $debugGetContentsFile) {
      my $response = $ua->get($TDCgetURL);
      $getContent = $response->content();
      if ($debug) {
	print STDERR "Saving $debugGetContentsFile\n";
	open O, ">$debugGetContentsFile";
	print O $getContent;
	close O;
      }
    } else {
      print STDERR "Getting from $debugGetContentsFile " . 
	"- delete it to refresh\n";
      open I, "$debugGetContentsFile";
      # Get the entire file all at once...
      $getContent = join("", <I>);
      close I;
    }
    # use Dbug ; dbugDump($getContent);
    $_initialGetTree = new HTML::TreeBuilder();
    $_initialGetTree->parse($getContent);
    $_initialGetTree->eof;
  }
  return $_initialGetTree;
}

my $_postForm;
sub getPostFormFromGetTree {
  if (! $_postForm) {
    $_postForm = getInitialGetTree()->look_down
      ('_tag' => 'form',
       'name' => 'getTVProgramsForm'
      );
  }
  return $_postForm;
}

################################################################################
# Return the channel list
################################################################################
sub getChannelHierarchy {
  my @channelHierarchy;
  my @allChannels;

  my @menu0s = getPostFormFromGetTree()->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu0'
    );

  my $menu0;

  # The first two are for the category - or "emne";
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'genre_hierarchy_start'
    or die "Expected genre_hierarchy_start here";
  $menu0 = shift @menu0s;
  
  # The next two are for the complate package - Fuldpakken;
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'fpchannel_hierarchy_start'
    or die "Expected fpchannel_hierarchy_start here";
  # This next one actually contains some stuff!!
  $menu0 = shift @menu0s;
  
  # We need to ensure that a channel isn't mentioned twice - only the
  # first place it is found will be shown.
  my %detectedChannelText;
  my %detectedChannelInput;
  # This is used for both Fuldpakken (fpchannel_hierarchy) and
  # selectorchannel_hierarchy
  my $getSubHierarchy = sub {
    my ($menu0) = @_;
    my @subHierarchy;
    my @menu1s = $menu0->look_down
      ( '_tag' => 'div',
	'class' => 'ktv_tvguide_menu1');
    while (my ($heading, $channels) = (shift @menu1s, shift @menu1s)) {
      last unless $heading and $channels;
      my $headingTitle = $heading->look_down('_tag' => 'a')->as_text();
      my @channels = $channels->look_down('_tag' => 'div',
					  'class' => 'ktv_tvguide_menu2');
      my @channelNameList;
      foreach my $ch (@channels) {
	my $inputName = $ch->look_down('_tag' => 'input')->attr('name')
	  or die "Expected a named input here";
	my $chName = $ch->as_text();
	my $xmltvid = getXmltvid($chName);
	unless ($detectedChannelText{$xmltvid} ||
		$detectedChannelInput{$inputName}
	       ) {
	  push @channelNameList, [ $xmltvid, $inputName ];
	  push @allChannels, [ $xmltvid, $inputName ];
	  $detectedChannelText{$xmltvid} = 1;
	  $detectedChannelInput{$inputName} = 1;
	} else {
	  # warn "Seen $xmltvid/$inputName before!";
	}
      }
      # The channelNameList can be empty if a subhier only contains
      # channels that are present in other packages too.
      push @subHierarchy, [ $headingTitle, \@channelNameList ]
	if (@channelNameList);
    }
    return @subHierarchy;
  };
  
  push @channelHierarchy, ['Fuldpakken', [&$getSubHierarchy($menu0)]];

  # The next two are for the complate package - Fuldpakken;
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'selectorchannel_hierarchy_start'
    or die "Expected selectorchannel_hierarchy_start here";
  # This next one actually contains some stuff!!
  $menu0 = shift @menu0s;
  push @channelHierarchy, ['Andre Pakker', [&$getSubHierarchy($menu0)]];
  return (\@allChannels, \@channelHierarchy);
}

################################################################################
# Now extract the available days from the lines of the get result
# The daySelect will contain something like this. It will vary depending
# on what day of the week we're called!!!
# <select name="portlet_search_1wlw-select_key:{pageFlow.selectedDay}" style="width:125px;" class="ktv_form_select"><option value="I går" style="width:125px;" class="ktv_form_select">I går</option><option value="En uge frem" style="width:125px;" class="ktv_form_select">En uge frem</option><option value="I dag" style="width:125px;" class="ktv_form_select" selected="true">I dag</option><option value="Mandag" style="width:125px;" class="ktv_form_select">Mandag</option><option value="Tirsdag" style="width:125px;" class="ktv_form_select">Tirsdag</option><option value="Onsdag" style="width:125px;" class="ktv_form_select">Onsdag</option><option value="Torsdag" style="width:125px;" class="ktv_form_select">Torsdag</option><option value="Fredag" style="width:125px;" class="ktv_form_select">Fredag</option><option value="Lørdag" style="width:125px;" class="ktv_form_select">Lørdag</option></select>
################################################################################
sub getDays {
  my $daySelect = getPostFormFromGetTree()->look_down
    ('_tag' => 'select',
     'name' => 'portlet_search_1wlw-select_key:{pageFlow.selectedDay}'
    );
  my @dayOptions = $daySelect->look_down('_tag'=>'option');
  # The first option is 'I går' - yesterday...
  shift @dayOptions;
  # The next option is 'Hele Ugen' - all week... But there is a limit
  # of 200 programs and a week for a channel can exceed that so we
  # won't try that.
  shift @dayOptions;
  my @days;
  foreach my $d (@dayOptions) {
    push @days, $d->attr('value');
  }
  return @days;
}

################################################################################
# Now extract the categories from the lines of the get result
# The contents we're looking for look somewhat like this:
# <div style="display:block" class="ktv_tvguide_menu0">
#         <div class="ktv_tvguide_menu1"><img src="/framework/skins/ktv/images/checkbox_hierachy/p.gif" onclick="tmi(this)"><img src="/framework/skins/ktv/images/checkbox_hierachy/ckb_1.gif" onclick="tch(this);"><input type="checkbox" style="display:none" name='htmlId_Bo_e_rn' ><a href="#">Børn</a></div>
#         <div class="ktv_tvguide_menu1" style="display:none">
#                 <div class="ktv_tvguide_menu2"><img src="/framework/skins/ktv/images/checkbox_hierachy/v.gif"><img src="/framework/skins/ktv/images/checkbox_hierachy/ckb_1.gif" onclick="tch(this);"><input type="checkbox" style="display:none" name='htmlId_36' ><a href="#">Mindre børn</a></div>
################################################################################
sub getEmneCheckBoxes {
  my @emneCheckboxes = ('AlleEmner');
  my $emneDiv = getPostFormFromGetTree()->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu0',
     # Luckily, the categories (emner) are "opened" at first, so we can
     # distinguish this div from others.
     'style' => 'display:block'
    );
  my @emneMenu1s = $emneDiv->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu1');
  while (@emneMenu1s) {
    my $menu1header = shift @emneMenu1s;
    my $input = $menu1header->look_down('_tag'=>'input');
    push @emneCheckboxes, $input->attr('name');
    my $menu1contents = shift @emneMenu1s;
    # The subcategories are contained herein...
    my @menu2s = $menu1contents->look_down('_tag'=>'div', 
					   'class'=> 'ktv_tvguide_menu2');
    foreach my $m (@menu2s) {
      my $input = $m->look_down('_tag'=>'input');
      push @emneCheckboxes, $input->attr('name');
    }
  }
  return @emneCheckboxes;
}

################################################################################
# Get the channels that are listed as chosen and unchosen in the config file
################################################################################
my $_firstLang;
sub getFirstLang {
  getConfiguration();
  return $_firstLang;
}

my $_creditsInDesc;
sub getCreditsInDesc {
  getConfiguration();
  return $_creditsInDesc;
}
my (@_chosen, @_unchosen);
sub getChannelConfiguration {
  getConfiguration();
  return (\@_chosen, \@_unchosen);
}

sub getConfiguration {
  # Use $_firstLang to keep track of whether we've read the config file.
  unless ($_firstLang) {
    open I, $config_file
      or die "Couldn't open $config_file for reading";
    my $firstLangLine = <I>;
    $firstLangLine =~ /^firstLang=(Original|Danish)$/
      or die "Unexpected /^firstLang=(Original|Danish)\$/ line in line 1 of $config_file";
    $_firstLang = $1;
    my $creditsInDescLine = <I>;
    $creditsInDescLine =~ /^creditsInDesc=(Yes|No)$/
      or die "Unexpected /^creditsInDesc=(Yes|No)$/ line in line 1 of $config_file";
    $_creditsInDesc = (lc $1 eq 'yes') ? 1 : 0;
    while (<I>) {
      /^(# )?(.*)/;
      my ($commentedOut, $xmltvid) = ($1, $2);
      if ($commentedOut) {
	push @_unchosen, $xmltvid;
      } else {
	push @_chosen, $xmltvid;
      }
    }
    close I;
  }
}

sub checkChannelConfiguration {
  my ($chosen, $unchosen) = getChannelConfiguration();
  my %chosen = map { $_ => 1 } @$chosen;
  my %unchosen = map { $_ => 1 } @$unchosen;
  my @missingInConfFile;
  my ($allChannels, $hierarchy) = getChannelHierarchy();
  foreach my $set (@$allChannels) {
    my ($xmltvid, $input) = @$set;
    my $found = 0;
    if ($chosen{$xmltvid}) {
      delete $chosen{$xmltvid};
    } elsif ($unchosen{$xmltvid}) {
      delete $unchosen{$xmltvid};
    } else {
      push @missingInConfFile, $xmltvid;
    }
  }
  my $error;
  if (@missingInConfFile) {
    print STDERR "**Error**: Missing in configuration file:\n";
    print STDERR map { "$_\n" } @missingInConfFile;
    $error = 1;
  }
  if (keys %chosen || keys %unchosen) {
    print STDERR "**Error**: No longer in Channel lineup:\n";
    print STDERR map { "$_\n" } keys %chosen, keys %unchosen;
    $error = 1;
  }
  if ($error) {
    exit 1;
  }
}
################################################################################
# Extract the POST url (including the jsessionid that presumably
# varies from invocation to invocation...)
################################################################################
sub getPostURL {
  return getPostFormFromGetTree()->attr('action');
}



################################################################################
# Does the user want to configure or to actually fetch something?
################################################################################
if ($mode eq 'configure') {
  if (-e $config_file) {
    if (! askBooleanQuestion "$config_file exists.\n".
	"Overwrite and discard current config file settings?", 1) {
      die "Editing config file not supported, only overwriting";
    }
  }
  open CONF_FILE, ">$config_file"
    or die "Couldn't open $config_file for writing";
  my $firstLang =  askQuestion
    ("Place titles of which language first in program listings",
     "Original",
     "Original", "Danish");
  
  print CONF_FILE "firstLang=$firstLang\n";
  
  my $creditsInDesc =  askBooleanQuestion
    ("Include credits in description (good for MythTV!)",1);
  
  printf CONF_FILE "creditsInDesc=%s\n",
     ($creditsInDesc) ? "Yes" : "No";
  my ($allChannels, $hierarchy) = getChannelHierarchy();
  foreach my $hier (@$hierarchy) {
    my ($hierName, $hierSubs) = @$hier;
    my $useHier = askQuestion("Channels from $hierName?",
			      "Some",
			      "Some",
			      "All",
			      "None");
    foreach my $sectionHier (@$hierSubs) {
      my ($section, $channels) = @$sectionHier;
      my $useSection;
      if ($useHier eq 'Some') {
	$useSection = askQuestion
	  ("  Channels from $hierName/$section?",
	   "Some",
	   "Some",
	   "All",
	   "None"
	   ); 
      } else {
	$useSection = $useHier;
      }
      foreach my $ch (@$channels) {
	my ($xmltvid, $id) = @$ch;
	my $channelName = getChannelName($xmltvid);
	my $useChannel;
	if ($useSection eq 'Some') {
	  $useChannel = askBooleanQuestion
	    ("    Channel $hierName/$section: $channelName?", 1); 
	} else {
	  $useChannel = ($useSection eq 'All') ? 1 : 0;
	}
	my $prefix = ($useChannel) ? "" : "# ";
	print CONF_FILE "${prefix}$xmltvid\n";
      }
    }
  }
  close CONF_FILE;
  print STDERR "\n\n$config_file written\n";
  print STDERR "Feel free to edit it by hand if you dare... :-D\n";
  exit;
} elsif ($mode ne 'grab' && $mode ne 'check-channels') {
  die "Don't know about mode $mode";
}

checkChannelConfiguration();

# If we're just checking the channels, we're done.
if ($mode eq 'check-channels') {
  print STDERR "Pass: Channel configuration is up-to-date\n";
  exit;
}
# Otherwise....

################################################################################
################################################################################
#
# The rest of the file is for grabbing...
#
################################################################################

sub getProgramsOnPage {
  my ($programDivContents) = @_;
  my $post = HTML::TreeBuilder->new();
  $post->parse($programDivContents);
  $post->eof;

  # Search for this in the postcontents:
  # <td colspan="4" class="ktv_portlet_list_text_header">
  # This will mark the beginning of a day. 
  # Note how all the programs of that day will consist of a 
  # <table></table> 
  #   and a
  # <div></div>
  #   and a
  # <script></script>
  # etc.
  
  my $firstDayTag = $post->look_down
    ('_tag' => 'td',
     'colspan' => 4,
     'class' => 'ktv_portlet_list_text_header');
  unless ($firstDayTag) {
    # print STDERR "Deleting\n";
    $post->delete;
    return ();
  }
    
  my $allDaysDiv;
  eval {
    $allDaysDiv = $firstDayTag->parent()->parent()->parent()->parent();
    $allDaysDiv->tag() eq 'div' or die;
  };
  die "Finding the start of all the program listings failed: $@" 
    if $@;
  my @programs;
  foreach my $dayDiv ($allDaysDiv->content_list()) {
    
    my @dayComponents = $dayDiv->content_list();
    # Each program consists of a table in the top - the part that
    # stays there, regardless of whether the details are visible, and
    # a div for the bottom, that can have its visibility toggled. The
    # contents of the bottom div is exactly one table.
    my $isFirstProgramOfDay=1;
    my $dayStr;
    my $dayFinished = 0;
    while (1) {
      my ($topTable, $botDiv, $script) = 
	(shift @dayComponents, shift @dayComponents, shift @dayComponents);
      # At the end of a day, there is a table with some stuff in it, but
      # no div.
      last unless $botDiv;

      ############################################################
      # Handle the top table
      ############################################################

      # Just checking :-D
      $topTable->tag() eq 'table' &&
	$botDiv->tag() eq 'div'
	  or die sprintf "Unexpected structure of the programs of a day.\n".
	    "Expected f and f but found %s and %s", 
	      $topTable->tag(), $botDiv->tag();
      # Now if this is the first program of a day, the first row will
      # contain a string with the date in it, and the second row will be
      # the time of the first program of that day. Otherwise there will
      # be two initial rows of garbage and then the time string.
      my @topRows = $topTable->content_list();
      if ($isFirstProgramOfDay) {
	$dayStr = $topRows[0]->as_text;
	# Beware - I've seen dates like:
	# Fredag d. 01 october 2004
	# - A mix of languages!!
	$dayStr =~ s/.*d\. //
	  or die "Expected to find a string like " .
	    "\"Torsdag d. 23 september 2004\" here";
	$isFirstProgramOfDay = 0;
      } else {
	shift @topRows;
      }

      my %prog;
      
      my $titleRow = $topRows[1];
      my ($timeTD, $danishTitleTD) = $titleRow->content_list();
      my $timeStr = $timeTD->as_text();

      $prog{danishTitle} = $danishTitleTD->as_text();
      $prog{danishTitle} =~ s/^ *//;
      $prog{danishTitle} =~ s/ *$//;
      
      $timeStr =~ /^(\d\d:\d\d) -(\d\d:\d\d)$/
	or die "Unexpected format for program time: '$timeStr'";
      my ($startStr, $stopStr) = ($1, $2);
      my $startTime = UnixDate(ParseDate($startStr . $dayStr), "%s");
      if (!$startTime) {
	die "Unexpected start time: $startStr $dayStr";
      }
      my $stopTime = UnixDate(ParseDate($stopStr . $dayStr), "%s");
      if (!$startTime) {
	die "Unexpected stop time: $stopStr $dayStr";
      }
      # Did we pass midnight?
      $stopTime += 24*60*60
	if ($stopTime < $startTime);
      $prog{start}=UnixDate(ParseDateString("epoch $startTime"),"%q");
      $prog{stop}=UnixDate(ParseDateString("epoch $stopTime"),"%q");

      my $subTitleRow = $topRows[2];
      my $subTitleTD = [$subTitleRow->content_list()]->[1];
      my ($programSpan, $dummySpace, $categorySpan) = 
	$subTitleTD->content_list();
      $prog{category} = $categorySpan->as_text();
      $prog{category} =~ s/^\( (.*) \)$/$1/
	or die "Unexpected format for program category '$prog{category}'";
      
      ############################################################
      # Handle bottom div's table
      ############################################################
      my @botTableRows=[$botDiv->content_list()]->[0]->content_list();
      $prog{desc} = $botTableRows[0]->as_text();
      $prog{desc} =~ s/\.$//;
      $prog{desc} =~ s/ *$//;
      $prog{desc} =~ s/^ *//;
      delete $prog{desc} 
	if $prog{desc} eq '';
      
      # I don't understand the system, but some programs have a dummy
      # row in between the description and the infotable. Detect this
      # here. Luckily this dummy row has a colspan=4 attribute.

      my $nextRowColspan = [$botTableRows[1]->content_list()]->[0]->
	attr('colspan');
      my $infoRowIndex = ($nextRowColspan) ? 2 : 1;
      my $infoHTML = [$botTableRows[$infoRowIndex]->content_list()]->[1]
	->as_HTML();
      chomp $infoHTML;
      my @infos = split(/<br>/, $infoHTML);
      # Medvirkende - participants - are a list of people - handle
      # them specially...
      my $medv = pop @infos;
      my @medv;
      my @medvStrings = split (m|</a> <a[^>]*>|, $medv);
      my $cleanHTML = sub {
	my ($html) = @_;
	$html =~ s/<[^>]*>//g;
	$html =~ s/&nbsp;/ /g;
	$html =~ s/[\. ]*$//;
	$html = decode_entities($html);
	return $html;
      };
      foreach (@medvStrings) {
	my $m = &$cleanHTML($_);
	$m =~ s/\s*m.fl$//;
	push @medv, $m
	  if ($m ne '');
      }
      $prog{medv} = \@medv
	if (@medv);

      # Now handle the rest of the info fields.
      foreach (qw(info genre danTit origTit varig inst medv)) {
	my $info = shift @infos;
	next unless $info;
	$info = &$cleanHTML($info);
	$prog{info}->{$_} = $info
	  if ($info ne '');
      }
      if (getCreditsInDesc()) {
	if ($prog{info}{inst}) {
	  $prog{desc} .= " Inst: " . $prog{info}{inst};
	}
	if (@medv) {
	  $prog{desc} .= " Medv: " . join(", ", @medv);
	}
	# We may have prepended a ' '...
	$prog{desc} =~ s/^ *//
	  if $prog{desc};
      }
      $prog{year} = $1
	if ($prog{info}{genre} && $prog{info}{genre} =~ /fra \d{4}$/);
      push @programs, \%prog;
    }
  }
  # print STDERR "Deleting\n";
  $post->delete;
  return @programs;
}

sub convertProgramToXMLTV {
  my ($p, $chanID) = @_;
  # Just checking...
  # Well, they can differ, actually...
  #   if ($$p{info}{danTit}) {
  #     die "How can danTit ($$p{info}{danTit}) differ from " .
  #       "danishTitle ($$p{danishTitle})?"
  # 	if ($$p{info}{danTit} ne $$p{danishTitle});
  #   }
  my @titles;
  if ($$p{info}{origTit}) {
    push @titles, [$$p{info}{origTit}];
  }
  push @titles, [$$p{danishTitle}, $LANG];

  if (scalar @titles == 2 && getFirstLang() eq 'Danish') {
    @titles = reverse @titles;
  }

  my $x = { 'channel' => $chanID,
	    'title' => \@titles,
	  };
  foreach (qw(start stop)) {
    $$x{$_} = $$p{$_}
      if $$p{$_};
  }

  foreach (qw(desc category)) {
    $$x{$_} = [[$$p{$_},$LANG]]
      if $$p{$_};
  }

  if ($$p{medv}) {
    $$x{credits}{actor}=$$p{medv};
  }
  if ($$p{info}{inst}) {
    $$x{credits}{director}=[$$p{info}{inst}];
  }

  $$x{date} = $$p{year}
    if ($$p{year});

  return $x;
}


################################################################################
# Assemble the POST parameters
################################################################################
my @globalPostParams = 
  ( [ 'portlet_search_1wlw-select_key:{pageFlow.selectedDay}OldValue', 'true' ],
    # This is set / iterated over later...
    # [ 'portlet_search_1wlw-select_key:{pageFlow.selectedDay}', 'I dag' ],
    [ 'portlet_search_1wlw-select_key:{pageFlow.selectedTimespan}OldValue',
      'true'],
    [ 'portlet_search_1wlw-select_key:{pageFlow.selectedTimespan}',
      'Hele dagen'],
  );

push @globalPostParams, map { [ $_, 'on' ] } getEmneCheckBoxes();


my ($allChannels) = getChannelHierarchy();
my %channelIDs;
foreach my $set (@$allChannels) {
  my ($name, $id) = @$set;
  $channelIDs{$name}=$id;
}

my ($chosen, $unchosen) = getChannelConfiguration();

my $writer;

unless ($debug && $debug eq "sequence") {
  my %writer_args;
  if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $writer_args{OUTPUT} = $fh;
  }
  $writer_args{encoding} = 'ISO-8859-1';
  $writer = new XMLTV::Writer(%writer_args);

  # TODO: standardize these things between grabbers.
  $writer->start
    ({ 'source-info-url'     => $TDCgetURL,
       'source-data-url'     => $TDCgetURL,
       'generator-info-name' => 'XMLTV',
       'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
     });
  foreach my $name (@$chosen) {
    $writer->write_channel({ 'id' => $name,
			     'display-name' => [[$name]] });
  }
}

my @days = getDays();
my $total = scalar (@$chosen) * scalar (@days);
my $i = 1;
CH: foreach my $channelName (@$chosen) {
  my $channelDisp = $channelName;
  $channelDisp =~ s/$xmltvidSuffix//;
  foreach my $day (@days) {
    printf STDERR "Getting channel: %-31s ".
      # "($channelIDs{$channelName}) " .
      "for: %-9s (%3d/$total = %3.0f%%)\n",
	$channelDisp, $day, $i,
	  100 * $i / $total;
    $i++;

    next 
      if ($debug && $debug eq "sequence");

    my @postLines;
    if ($debug and $debug eq "parse" && -e "$debugPostContentsFile") {
      print STDERR "Faking it - reading post data from " .
	"$debugPostContentsFile\n";
      open I,"$debugPostContentsFile"
	or die "Huh?";
      @postLines = <I>;
      close I;
    } else {
      my @postParams = @globalPostParams;
    
      push @postParams, [ 'portlet_search_1wlw-select_key:{pageFlow.selectedDay}',
			  $day ];
      push @postParams, [$channelIDs{$channelName},'on'];
    
      my @lwpPostParams;
      foreach my $set (@postParams) {
	my ($k, $v) = @$set;
	push @lwpPostParams, $k, $v;
      }
    
      my $postResponse = $ua->post
	(getPostURL(), 
	 \@lwpPostParams, 
	);

      # use Dbug ; dbugDump(\@lwpPostParams);
      if ($debug && $debug eq "parse" && ! -e "$debugPostContentsFile") {
	open O,">$debugPostContentsFile"
	  or die "Huh?";
	print O $postResponse->content();
	close O;
	print STDERR "Wrote $debugPostContentsFile\n";
      }
      @postLines = split("\n", $postResponse->content());
    }

    # Somewhere in the post contents, there are a set of lines like this:
    #
    # <script type="text/javascript" src="/framework/skins/ktv/js/ktv.js"></script>
    # <div class="ktv_portlet_container">
    # <div class="ktv_portlet_text_header">TV-oversigten</div>
    # <div class="ktv_portlet_text_body">
    #     <span>Hele dagen</span>
    #     - <span>Flere emner</span>
    #     - <span>Flere kanaler</span>
    #     <br><span>Der blev fundet 38 udsendelser.</span>
    # </div>  
    # <div>
    #     
    # 	All program info is in this div!
    # 
    # </div>
    #
    # Taking out that div so only *it* gets parsed speeds this script
    # up so it runs in about 50% of the time... Lets do that.
    
    my @divPostLines;
    while ($postLines[0] && 
	   $postLines[0] !~ m|<div class="ktv_portlet_text_body">|) {
      shift @postLines;
    }
    while ($postLines[0] && $postLines[0] !~ m|^<div>|) {
      shift @postLines;
    }
    while ($postLines[0] && $postLines[0] !~ m|^</div>|) {
      push @divPostLines, shift @postLines;
    }
    push @divPostLines, "</div>\n";

    my $programDivContents = join ("", @divPostLines);
    foreach (getProgramsOnPage($programDivContents)) {
      # dbugDump($_);
      # dbugDump(convertProgramToXMLTV($_, 'TV4'));
	$writer->write_programme(convertProgramToXMLTV($_, $channelName));
    }
    if ($debug && $debug eq "parse") {
      print STDERR "Finishing early due to debugging the parsing\n";
      # askBooleanQuestion("Exit",1);	
      last CH;
    }
  }
}
unless ($debug && $debug eq "sequence") {
  $writer->end();
}
